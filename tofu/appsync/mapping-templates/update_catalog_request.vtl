#set($now = $util.time.nowISO8601())
## Add productId to each product if not present
#set($productsWithIds = [])
#foreach($product in $ctx.args.input.products)
    #set($productWithId = {
        "productName": $product.productName,
        "price": $product.price,
        "sortOrder": $product.sortOrder
    })
    ## Preserve existing productId or generate new one
    #if($product.productId)
        $util.qr($productWithId.put("productId", $product.productId))
    #else
        #set($newProductId = "PRODUCT#$util.autoId()")
        $util.qr($productWithId.put("productId", $newProductId))
    #end
    #if($product.description)
        $util.qr($productWithId.put("description", $product.description))
    #end
    $util.qr($productsWithIds.add($productWithId))
#end
## Convert isPublic boolean to string for GSI
#if($ctx.args.input.isPublic)
    #set($isPublicStr = "true")
#else
    #set($isPublicStr = "false")
#end
#set($ownerWithPrefix = "ACCOUNT#$ctx.identity.sub")
{
    "version": "2017-02-28",
    "operation": "UpdateItem",
    "key": {
        "catalogId": $util.dynamodb.toDynamoDBJson($ctx.args.catalogId)
    },
    "update": {
        "expression": "SET catalogName = :catalogName, isPublic = :isPublic, isPublicStr = :isPublicStr, products = :products, updatedAt = :updatedAt",
        "expressionValues": {
        ":catalogName": $util.dynamodb.toDynamoDBJson($ctx.args.input.catalogName),
        ":isPublic": $util.dynamodb.toDynamoDBJson($isPublicStr),
        ":isPublicStr": $util.dynamodb.toDynamoDBJson($isPublicStr),
        ":products": $util.dynamodb.toDynamoDBJson($productsWithIds),
        ":updatedAt": $util.dynamodb.toDynamoDBJson($now)
        }
    },
    "condition": {
        "expression": "attribute_exists(catalogId) AND ownerAccountId = :ownerId",
        "expressionValues": {
        ":ownerId": $util.dynamodb.toDynamoDBJson($ownerWithPrefix)
        }
    }
}
